{"version":3,"file":"index.cjs.js","sources":["../../src/enhancers/helpers/index.ts","../../src/enhancers/helpers/logger.ts","../../src/constants.ts","../../src/enhancers/withPersistTokens/constants.ts","../../src/enhancers/withPersistTokens/helpers.ts","../../src/enhancers/withFingerprint/constants.ts","../../src/enhancers/withFingerprint/helpers.ts","../../src/enhancers/withFingerprint/index.ts","../../src/enhancers/withLastLoggedInUser/constants.ts","../../src/enhancers/withLastLoggedInUser/helpers.ts","../../src/enhancers/withLastLoggedInUser/index.ts","../../src/enhancers/withNotifications/helpers.ts","../../src/enhancers/withNotifications/index.ts","../../src/enhancers/withPersistTokens/index.ts","../../src/sdk/webauthn.ts","../../src/apiPaths.ts","../../src/sdk/fedcm.ts","../../src/sdk/flow.ts","../../src/sdk/index.ts","../../src/index.ts","../../src/enhancers/helpers/compose.ts","../../src/enhancers/withAutoRefresh/index.ts","../../src/enhancers/withAutoRefresh/helpers.ts","../../src/enhancers/withAnalytics.ts"],"sourcesContent":["import { JWTResponse, UserResponse } from '@descope/core-js-sdk';\nimport { CoreSdkConfig } from '../../types';\n\n/**\n * Add hooks to an existing core-sdk config\n */\nexport const addHooks = <Config extends CoreSdkConfig>(\n  config: Config,\n  hooks: Config['hooks'],\n): Config => {\n  ['beforeRequest', 'afterRequest'].reduce(\n    (acc, key) => {\n      acc[key] = []\n        .concat(config.hooks?.[key] || [])\n        .concat(hooks?.[key] || []);\n\n      return acc;\n    },\n    (config.hooks ??= {}),\n  );\n\n  return config;\n};\n\nexport { compose } from './compose';\n\n/**\n * Extract auth info (JWT response) from fetch response\n * We assume that the auth info is under a \"authInfo\" attribute (flow response)\n * Or the body itself (other auth methods response)\n */\nexport const getAuthInfoFromResponse = async (\n  res: Response,\n): Promise<Partial<JWTResponse>> => {\n  if (!res?.ok) return {};\n  const body = await res?.clone().json();\n  return body?.authInfo || body || {};\n};\n\n/**\n * Extract user from fetch response\n * User my exist under \"user\" attribute (auth methods response)\n * Or the body itself (when calling \"me\")\n */\nexport const getUserFromResponse = async (\n  res: Response,\n): Promise<UserResponse> | undefined => {\n  const authInfo = await getAuthInfoFromResponse(res);\n\n  return (\n    authInfo?.user ||\n    (authInfo?.hasOwnProperty('userId')\n      ? (authInfo as UserResponse)\n      : undefined)\n  );\n};\n\nexport const isLocalStorage = typeof localStorage !== 'undefined';\n\nexport const setLocalStorage = (key: string, value: string) =>\n  isLocalStorage && localStorage?.setItem(key, value);\nexport const getLocalStorage = (key: string) =>\n  isLocalStorage && localStorage?.getItem(key);\nexport const removeLocalStorage = (key: string) =>\n  isLocalStorage && localStorage?.removeItem(key);\n","const logger = {\n  debug: (...args: any[]) => {\n    // eslint-disable-next-line no-console\n    console.debug(...args);\n  },\n};\n\nexport default logger;\n","// This sdk can be used in SSR apps\nexport const IS_BROWSER = typeof window !== 'undefined';\n\n// Maximum timeout value for setTimeout\n// For more information, refer to https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#maximum_delay_value\nexport const MAX_TIMEOUT = Math.pow(2, 31) - 1;\n","/** Default name for the session cookie name / local storage key */\nexport const SESSION_TOKEN_KEY = 'DS';\n/** Default name for the refresh local storage key */\nexport const REFRESH_TOKEN_KEY = 'DSR';\n","import { JWTResponse } from '@descope/core-js-sdk';\nimport Cookies from 'js-cookie';\nimport { BeforeRequestHook } from '../../types';\nimport { REFRESH_TOKEN_KEY, SESSION_TOKEN_KEY } from './constants';\nimport {\n  getLocalStorage,\n  removeLocalStorage,\n  setLocalStorage,\n} from '../helpers';\n\n/**\n * Store the session JWT as a cookie on the given domain and path with the given expiration.\n * This is useful so that the application backend will automatically get the cookie for the session\n * @param name cookie name\n * @param value The JWT to store as a cookie\n * @param cookieParams configuration that is usually returned from the JWT\n */\nfunction setJwtTokenCookie(\n  name: string,\n  value: string,\n  { cookiePath, cookieDomain, cookieExpiration }: Partial<JWTResponse>,\n) {\n  if (value) {\n    const expires = new Date(cookieExpiration * 1000); // we are getting response from the server in seconds instead of ms\n    // Since its a JS cookie, we don't set the domain because we want the cookie to be on the same domain as the application\n    const domainMatches = isCurrentDomainOrParentDomain(cookieDomain);\n    Cookies.set(name, value, {\n      path: cookiePath,\n      domain: domainMatches ? cookieDomain : undefined,\n      expires,\n      sameSite: 'Strict',\n      secure: true,\n    });\n  }\n}\n\n/*\n * Check if the cookie domain is the same as the current domain or the parent domain\n * Examples:\n * 1. cookie domain: 'example.com', current domain: 'example.com' => true\n * 2. cookie domain: 'example.com', current domain: 'sub.example.com' => true\n * 3. cookie domain: 'example.com', current domain: 'sub.sub.example.com' => true\n * 4. cookie domain: 'example.com', current domain: 'another.com' => false\n * 5. cookie domain: 'example.com', current domain: 'example.co.il' => false\n */\nfunction isCurrentDomainOrParentDomain(cookieDomain: string): boolean {\n  const currentDomain = window.location.hostname;\n  const currentDomainParts = currentDomain.split('.');\n  const cookieDomainParts = cookieDomain.split('.');\n\n  // check if the cookie domain items are the last items in the current domain\n  const currentDomainSuffix = currentDomainParts\n    .slice(-cookieDomainParts.length)\n    .join('.');\n  return currentDomainSuffix === cookieDomain;\n}\n\nexport const persistTokens = (\n  { refreshJwt, sessionJwt, ...cookieParams } = {} as Partial<JWTResponse>,\n  sessionTokenViaCookie = false,\n  storagePrefix = '',\n) => {\n  // persist refresh token\n  refreshJwt &&\n    setLocalStorage(`${storagePrefix}${REFRESH_TOKEN_KEY}`, refreshJwt);\n\n  // persist session token\n  if (sessionJwt) {\n    sessionTokenViaCookie\n      ? setJwtTokenCookie(SESSION_TOKEN_KEY, sessionJwt, cookieParams)\n      : setLocalStorage(`${storagePrefix}${SESSION_TOKEN_KEY}`, sessionJwt);\n  }\n};\n\n/** Return the refresh token from the localStorage. Not for production usage because refresh token will not be saved in localStorage. */\nexport function getRefreshToken(prefix: string = '') {\n  return getLocalStorage(`${prefix}${REFRESH_TOKEN_KEY}`) || '';\n}\n\n/**\n * Return the session token. first try to get from cookie, and fallback to local storage\n * See sessionTokenViaCookie option for more details about session token location\n */\nexport function getSessionToken(prefix: string = ''): string {\n  return (\n    Cookies.get(SESSION_TOKEN_KEY) ||\n    getLocalStorage(`${prefix}${SESSION_TOKEN_KEY}`) ||\n    ''\n  );\n}\n\n/** Remove both the localStorage refresh JWT and the session cookie */\nexport function clearTokens(prefix: string = '') {\n  removeLocalStorage(`${prefix}${REFRESH_TOKEN_KEY}`);\n  removeLocalStorage(`${prefix}${SESSION_TOKEN_KEY}`);\n  Cookies.remove(SESSION_TOKEN_KEY);\n}\n\nexport const beforeRequest =\n  (prefix?: string): BeforeRequestHook =>\n  (config) =>\n    Object.assign(config, { token: config.token || getRefreshToken(prefix) });\n","import { IS_BROWSER } from '../../constants';\n\nconst FINGERPRINT_PUBLIC_KEY = 'fingerprint.public.key';\nconst FINGERPRINT_ENDPOINT_URL = 'fingerprint.endpoint.url';\n\n/** Fingerprint.js cloudflare integration */\nexport const FP_EP_URL =\n  (IS_BROWSER && localStorage?.getItem(FINGERPRINT_ENDPOINT_URL)) ||\n  'https://api.descope.com';\nexport const FP_CF_ENDPOINT_PATH = '/fXj8gt3x8VulJBna/x96Emn69oZwcd7I6';\nexport const FP_CF_SCRIPT_PATH = '/fXj8gt3x8VulJBna/w78aRZnnDZ3Aqw0I';\n/** Fingerprint visitor data */\nexport const FP_BODY_DATA = 'fpData';\n/** Session ID for visitor */\nexport const VISITOR_SESSION_ID_PARAM = 'vsid';\n/** Request ID for visitor */\nexport const VISITOR_REQUEST_ID_PARAM = 'vrid';\n/** FP storage key */\nexport const FP_STORAGE_KEY = 'fp';\n// Storage FP Keys TTL is 24 hours\nexport const STORAGE_TTL_MS = 24 * 60 * 60 * 1000;\n","import {\n  load,\n  defaultEndpoint,\n  defaultScriptUrlPattern,\n} from '@fingerprintjs/fingerprintjs-pro';\nimport {\n  FP_EP_URL,\n  FP_CF_ENDPOINT_PATH,\n  FP_CF_SCRIPT_PATH,\n  FP_STORAGE_KEY,\n  STORAGE_TTL_MS,\n  VISITOR_REQUEST_ID_PARAM,\n  VISITOR_SESSION_ID_PARAM,\n} from './constants';\nimport { FingerprintObject } from './types';\n\nconst createFingerprintObject = (\n  sessionId: string,\n  requestId: string,\n): FingerprintObject => ({\n  [VISITOR_SESSION_ID_PARAM]: sessionId,\n  [VISITOR_REQUEST_ID_PARAM]: requestId,\n});\n\n/** Generate UUID based on current time and some randomness */\nconst generateUUID = () => {\n  // return alphanumeric, sortable uuid of 27 characters\n  return (\n    Date.now().toString(36) +\n    Math.random().toString(36).substring(2) + // removing '0.' prefix\n    Math.random().toString(36).substring(2)\n  ).substring(0, 27);\n};\n\n// Set FP data to storage with expiration\n// We set the request id and session id together so they will have the same TTL\n// This implementation is based on https://www.sohamkamani.com/javascript/localstorage-with-ttl-expiry/\nconst setFPToStorage = (value: FingerprintObject) => {\n  const now = new Date();\n  // `item` is an object which contains the value\n  // as well as the time when it's supposed to expire\n  const item = {\n    value,\n    expiry: now.getTime() + STORAGE_TTL_MS,\n  };\n  localStorage.setItem(FP_STORAGE_KEY, JSON.stringify(item));\n};\n\n// Get Fingerprint from storage, will return null if not exists, or if expired\nconst getFPFromStorage = (returnExpired = false): FingerprintObject => {\n  const itemStr = localStorage.getItem(FP_STORAGE_KEY);\n  // if the item doesn't exist, return null\n  if (!itemStr) {\n    return null;\n  }\n  const item = JSON.parse(itemStr);\n  const now = new Date();\n  // compare the expiry time of the item with the current time\n  // return null if needed\n  if (now.getTime() > item.expiry && !returnExpired) {\n    return null;\n  }\n  return item.value;\n};\n\n/**\n * Ensure fingerprint ids (request id, session id) exist.\n * If not, It will generate and load them into to browser storage.\n * NOTE: Using fingerprintJS data has cost, use considerably.\n * @param fpKey FingerprintJS API key\n */\nexport const ensureFingerprintIds = async (\n  fpKey: string,\n  baseUrl = FP_EP_URL,\n) => {\n  try {\n    if (getFPFromStorage()) {\n      // FP is already in storage, no need to\n      return;\n    }\n\n    const sessionId = generateUUID();\n\n    const endpointUrl = new URL(baseUrl);\n    endpointUrl.pathname = FP_CF_ENDPOINT_PATH;\n\n    const patterUrl = new URL(baseUrl);\n    patterUrl.pathname = FP_CF_SCRIPT_PATH;\n    const scriptUrlPattern =\n      patterUrl.toString() +\n      '?apiKey=<apiKey>&version=<version>&loaderVersion=<loaderVersion>';\n\n    // load from FingerprintJS\n    const agentP = load({\n      apiKey: fpKey,\n      endpoint: [\n        endpointUrl.toString(),\n        defaultEndpoint, // Fallback to default endpoint in case of error\n      ],\n      scriptUrlPattern: [\n        scriptUrlPattern,\n        defaultScriptUrlPattern, // Fallback to default CDN in case of error\n      ],\n    });\n\n    const agent = await agentP;\n    const { requestId } = await agent.get({ linkedId: sessionId });\n    const fpData = createFingerprintObject(sessionId, requestId);\n    setFPToStorage(fpData);\n  } catch (ex) {\n    // eslint-disable-next-line no-console\n    console.warn('Could not load fingerprint', ex);\n  }\n};\n\n/**\n * Get Fingerprint data (request ids) from storage, or create empty object\n * If data is expired, return it anyway\n */\nexport const getFingerprintData = (): FingerprintObject | null => {\n  // get from storage if exists\n  return getFPFromStorage(true);\n};\n\n/** Clear Fingerprint data from storage */\nexport const clearFingerprintData = () => {\n  localStorage.removeItem(FP_STORAGE_KEY);\n};\n","import { IS_BROWSER } from '../../constants';\nimport { CreateWebSdk } from '../../sdk';\nimport { BeforeRequestHook } from '../../types';\nimport { addHooks } from '../helpers';\nimport { FP_BODY_DATA } from './constants';\nimport { ensureFingerprintIds, getFingerprintData } from './helpers';\nimport { FingerprintOptions } from './types';\n\nconst beforeRequest: BeforeRequestHook = (config) => {\n  const data = getFingerprintData();\n  if (data && config.body) {\n    config.body[FP_BODY_DATA] = data;\n  }\n\n  return config;\n};\n\n/**\n * Add fingerprint data to outgoing requests\n */\nexport const withFingerprint =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  ({ fpKey, fpLoad, ...config }: Parameters<T>[0] & FingerprintOptions) => {\n    if (!IS_BROWSER) {\n      // Fingerprint is a client side only capability and will not work when running in the server (SSR)\n      return createSdk(config);\n    }\n\n    // load fingerprint now if needed\n    if (fpKey && fpLoad) {\n      ensureFingerprintIds(fpKey).catch(\n        // istanbul ignore next\n        () => null,\n      );\n    }\n\n    // Hook added always because fingerprint can be dynamic using flows\n    return createSdk(addHooks(config, { beforeRequest }));\n  };\n","/** Login Id of the last user logged in */\nexport const LOCAL_STORAGE_LAST_USER_LOGIN_ID = 'dls_last_user_login_id';\n\n/** Display name of the last user logged in */\nexport const LOCAL_STORAGE_LAST_USER_DISPLAY_NAME =\n  'dls_last_user_display_name';\n","import {\n  getLocalStorage,\n  removeLocalStorage,\n  setLocalStorage,\n} from '../helpers';\nimport {\n  LOCAL_STORAGE_LAST_USER_LOGIN_ID,\n  LOCAL_STORAGE_LAST_USER_DISPLAY_NAME,\n} from './constants';\n\nexport const setLastUserLoginId = (loginId: string) => {\n  return setLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID, loginId);\n};\n\nexport const getLastUserLoginId = () => {\n  return getLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID);\n};\n\nexport const removeLastUserLoginId = () => {\n  return removeLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID);\n};\n\nexport const setLastUserDisplayName = (displayName: string) => {\n  return setLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME, displayName);\n};\n\nexport const getLastUserDisplayName = () => {\n  return getLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME);\n};\n\nexport const removeLastUserDisplayName = () => {\n  return removeLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME);\n};\n","import { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook, CoreSdk } from '../../types';\nimport { addHooks, getUserFromResponse } from '../helpers';\nimport {\n  getLastUserLoginId,\n  removeLastUserLoginId,\n  setLastUserLoginId,\n  getLastUserDisplayName,\n  removeLastUserDisplayName,\n  setLastUserDisplayName,\n} from './helpers';\nimport { LastLoggedInUserOptions } from './types';\n\n/**\n * Adds last logged in user to flow start request\n */\n// eslint-disable-next-line import/exports-last\nexport const withLastLoggedInUser =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  ({\n    storeLastAuthenticatedUser = true,\n    keepLastAuthenticatedUserAfterLogout = false,\n    ...config\n  }: Parameters<T>[0] & LastLoggedInUserOptions): ReturnType<T> & {\n    getLastUserLoginId: typeof getLastUserLoginId;\n    getLastUserDisplayName: typeof getLastUserDisplayName;\n  } => {\n    if (!storeLastAuthenticatedUser) {\n      // We assign getLastUserLoginId and getLastUserDisplayName to the sdk\n      // To keep the return type consistent\n      return Object.assign(createSdk(config), {\n        getLastUserLoginId,\n        getLastUserDisplayName,\n      }) as any;\n    }\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      const userDetails = await getUserFromResponse(res);\n      const loginId = userDetails?.loginIds?.[0];\n      const displayName = userDetails?.name;\n      if (loginId) {\n        setLastUserLoginId(loginId);\n        setLastUserDisplayName(displayName);\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    let wrappedSdk = wrapWith(sdk, ['flow.start'], startWrapper);\n    wrappedSdk = wrapWith(\n      wrappedSdk,\n      ['logout', 'logoutAll'],\n      logoutWrapper(keepLastAuthenticatedUserAfterLogout),\n    );\n    return Object.assign(wrappedSdk, {\n      getLastUserLoginId,\n      getLastUserDisplayName,\n    }) as any;\n  };\n\nconst startWrapper: SdkFnWrapper<{}> =\n  (fn) =>\n  async (...args) => {\n    args[1] = args[1] || {};\n    const [, options = {}] = args as unknown as Parameters<\n      CoreSdk['flow']['start']\n    >;\n    const loginId = getLastUserLoginId();\n    const displayName = getLastUserDisplayName();\n\n    if (loginId) {\n      options.lastAuth ??= {};\n      options.lastAuth.loginId = loginId;\n      options.lastAuth.name = displayName;\n    }\n\n    const resp = await fn(...args);\n\n    return resp;\n  };\n\nconst logoutWrapper =\n  (keepOnLogout?: boolean): SdkFnWrapper<{}> =>\n  (fn) =>\n  async (...args) => {\n    const resp = await fn(...args);\n    if (keepOnLogout) {\n      return resp;\n    }\n\n    removeLastUserLoginId();\n    removeLastUserDisplayName();\n\n    return resp;\n  };\n","// create publisher/subscriber instances\nexport function createPubSub<T extends any>() {\n  const cbs = [];\n\n  const sub = (cb: (data: T) => void) => {\n    const idx = cbs.push(cb) - 1;\n    return () => cbs.splice(idx, 1);\n  };\n\n  const pub = (data: T) => {\n    cbs.forEach((cb) => cb(data));\n  };\n\n  return { pub, sub };\n}\n","import { SdkFnWrapper, UserResponse, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk, WebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport {\n  addHooks,\n  getAuthInfoFromResponse,\n  getUserFromResponse,\n} from '../helpers';\nimport { createPubSub } from './helpers';\n\n/**\n * Adds 2 event functions to the sdk,\n * onSessionTokenChange: Gets a callback and call it whenever there is a change in session token\n * onUserChange: Gets a callback and call it whenever there is a change in current logged in user\n */\nexport const withNotifications =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  (config: Parameters<T>[0]) => {\n    const sessionPS = createPubSub<string | null>();\n    const userPS = createPubSub<UserResponse | null>();\n\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      if (res?.status === 401) {\n        sessionPS.pub(null);\n        userPS.pub(null);\n      } else {\n        const userDetails = await getUserFromResponse(res);\n        if (userDetails) userPS.pub(userDetails);\n\n        const { sessionJwt } = await getAuthInfoFromResponse(res);\n        if (sessionJwt) sessionPS.pub(sessionJwt);\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    const wrapper: SdkFnWrapper<{}> =\n      (fn) =>\n      async (...args) => {\n        const resp = await fn(...args);\n\n        sessionPS.pub(null);\n        userPS.pub(null);\n\n        return resp;\n      };\n\n    const wrappedSdk = wrapWith(sdk, ['logout', 'logoutAll'], wrapper);\n\n    return Object.assign(wrappedSdk, {\n      onSessionTokenChange: sessionPS.sub,\n      onUserChange: userPS.sub,\n    });\n  };\n","/* eslint-disable import/exports-last */\nimport { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { IS_BROWSER } from '../../constants';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport { addHooks, getAuthInfoFromResponse } from '../helpers';\nimport {\n  beforeRequest,\n  clearTokens,\n  getRefreshToken,\n  getSessionToken,\n  persistTokens,\n} from './helpers';\nimport { PersistTokensOptions } from './types';\n\n/**\n * Persist authentication tokens in cookie/storage\n */\nexport const withPersistTokens =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  <A extends boolean>({\n    persistTokens: isPersistTokens,\n    sessionTokenViaCookie,\n    storagePrefix,\n    ...config\n  }: Parameters<T>[0] & PersistTokensOptions<A>): A extends true\n    ? ReturnType<T> & {\n        getRefreshToken: () => string;\n        getSessionToken: () => string;\n      }\n    : ReturnType<T> => {\n    if (!isPersistTokens || !IS_BROWSER) {\n      if (isPersistTokens) {\n        // Storing auth tokens in local storage and cookies are a client side only capabilities\n        // and will not be done when running in the server\n      }\n      return createSdk(config) as any;\n    }\n\n    const afterRequest: AfterRequestHook = async (req, res) => {\n      const isManagementApi = /^\\/v\\d+\\/mgmt\\//.test(req.path);\n\n      if (res?.status === 401) {\n        if (!isManagementApi) {\n          clearTokens(storagePrefix);\n        }\n      } else {\n        persistTokens(\n          await getAuthInfoFromResponse(res),\n          sessionTokenViaCookie,\n          storagePrefix,\n        );\n      }\n    };\n\n    const sdk = createSdk(\n      addHooks(config, {\n        beforeRequest: beforeRequest(storagePrefix),\n        afterRequest,\n      }),\n    );\n\n    const wrappedSdk = wrapWith(\n      sdk,\n      ['logout', 'logoutAll'],\n      wrapper(storagePrefix),\n    );\n\n    const refreshToken = () => getRefreshToken(storagePrefix);\n    const sessionToken = () => getSessionToken(storagePrefix);\n\n    return Object.assign(wrappedSdk, {\n      getRefreshToken: refreshToken,\n      getSessionToken: sessionToken,\n    }) as any;\n  };\n\nconst wrapper =\n  (prefix?: string): SdkFnWrapper<{}> =>\n  (fn) =>\n  async (...args) => {\n    const resp = await fn(...args);\n\n    clearTokens(prefix);\n\n    return resp;\n  };\n\nexport default withPersistTokens;\n","import { JWTResponse, SdkResponse, ResponseData } from '@descope/core-js-sdk';\nimport { IS_BROWSER } from '../constants';\nimport { CoreSdk } from '../types';\n\ntype CreateWebauthn = typeof createWebAuthn;\n\nconst withCoreFns =\n  <I extends Parameters<CreateWebauthn>, O extends ReturnType<CreateWebauthn>>(\n    creator: (...args: I) => O,\n  ) =>\n  (...args: I) => {\n    const obj = creator(...args);\n\n    Object.assign(obj.signUp, args[0].webauthn.signUp);\n    Object.assign(obj.signIn, args[0].webauthn.signIn);\n    Object.assign(obj.signUpOrIn, args[0].webauthn.signUpOrIn);\n    Object.assign(obj.update, args[0].webauthn.update);\n\n    return obj as {\n      [K in keyof O]: K extends keyof I[0]['webauthn']\n        ? O[K] & I[0]['webauthn'][K]\n        : O[K];\n    };\n  };\n\n/** Constructs a higher level WebAuthn API that wraps the functions from code-js-sdk */\nconst createWebAuthn = (sdk: CoreSdk) => ({\n  async signUp(identifier: string, name: string) {\n    const startResponse = await sdk.webauthn.signUp.start(\n      identifier,\n      window.location.origin,\n      name,\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    const createResponse = await create(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.signUp.finish(\n      startResponse.data.transactionId,\n      createResponse,\n    );\n    return finishResponse;\n  },\n\n  async signIn(identifier: string) {\n    const startResponse = await sdk.webauthn.signIn.start(\n      identifier,\n      window.location.origin,\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    const getResponse = await get(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.signIn.finish(\n      startResponse.data.transactionId,\n      getResponse,\n    );\n    return finishResponse;\n  },\n\n  async signUpOrIn(identifier: string) {\n    const startResponse = await sdk.webauthn.signUpOrIn.start(\n      identifier,\n      window.location.origin,\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    if (startResponse.data?.create) {\n      const createResponse = await create(startResponse.data.options);\n      const finishResponse = await sdk.webauthn.signUp.finish(\n        startResponse.data.transactionId,\n        createResponse,\n      );\n      return finishResponse;\n    } else {\n      const getResponse = await get(startResponse.data.options);\n      const finishResponse = await sdk.webauthn.signIn.finish(\n        startResponse.data.transactionId,\n        getResponse,\n      );\n      return finishResponse;\n    }\n  },\n\n  async update(identifier: string, token: string) {\n    const startResponse = await sdk.webauthn.update.start(\n      identifier,\n      window.location.origin,\n      token,\n    );\n    if (!startResponse.ok) {\n      return startResponse as SdkResponse<ResponseData>;\n    }\n    const createResponse = await create(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.update.finish(\n      startResponse.data.transactionId,\n      createResponse,\n    );\n    return finishResponse;\n  },\n\n  /** Helper functions for working with WebAuthn browser APIs using JSON data */\n  helpers: {\n    /** Wraps the navigation.credentials.create call to translate JSON inputs and outputs */\n    create,\n    /** Wraps the navigation.credentials.get call to translate JSON inputs and outputs */\n    get,\n    /** Checks if the browser supports WebAuthn, and can optionally require in\n     * addition that the browser supports WebAuthn with built-in biometrics */\n    isSupported,\n    conditional,\n  },\n});\n\n// Helpers functions\n\nasync function create(options: string): Promise<string> {\n  const createOptions = decodeCreateOptions(options);\n  const createResponse = (await navigator.credentials.create(\n    createOptions,\n  )) as AttestationPublicKeyCredential;\n  return encodeCreateResponse(createResponse);\n}\n\nasync function get(options: string): Promise<string> {\n  const getOptions = decodeGetOptions(options);\n  const getResponse = (await navigator.credentials.get(\n    getOptions,\n  )) as AssertionPublicKeyCredential;\n  return encodeGetResponse(getResponse);\n}\n\n/**\n * This function should be used in passkeys autofill (conditional UI)\n * It handles the call to \"navigator.credentials.get\" and adds the required options\n * @param options webauthn start options\n * @param abort: AbortController instance\n * @returns encoded \"navigator.credentials.get\" response\n */\nasync function conditional(\n  options: string,\n  abort: AbortController,\n): Promise<string> {\n  const getOptions = decodeGetOptions(options);\n  getOptions.signal = abort.signal;\n  getOptions.mediation = 'conditional' as any;\n  const getResponse = (await navigator.credentials.get(\n    getOptions,\n  )) as AssertionPublicKeyCredential;\n  return encodeGetResponse(getResponse);\n}\n\n// eslint-disable-next-line import/exports-last\nexport async function isSupported(\n  requirePlatformAuthenticator: boolean = false,\n): Promise<boolean> {\n  if (!IS_BROWSER) {\n    return Promise.resolve(false);\n  }\n  const supported = !!(\n    window.PublicKeyCredential &&\n    navigator.credentials &&\n    navigator.credentials.create &&\n    navigator.credentials.get\n  );\n  if (\n    supported &&\n    requirePlatformAuthenticator &&\n    PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable\n  ) {\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n  }\n  return supported;\n}\n\n// Conversion of data structures for Create/Attestation/Register ceremony\n\ntype AttestationPublicKeyCredential = PublicKeyCredential & {\n  response: AuthenticatorAttestationResponse;\n};\n\nfunction decodeCreateOptions(value: string): CredentialCreationOptions {\n  const options = JSON.parse(value);\n  options.publicKey.challenge = decodeBase64Url(options.publicKey.challenge);\n  options.publicKey.user.id = decodeBase64Url(options.publicKey.user.id);\n  options.publicKey.excludeCredentials?.forEach((item: any) => {\n    item.id = decodeBase64Url(item.id);\n  });\n  return options;\n}\n\nfunction encodeCreateResponse(\n  credential: AttestationPublicKeyCredential,\n): string {\n  return JSON.stringify({\n    id: credential.id,\n    rawId: encodeBase64Url(credential.rawId),\n    type: credential.type,\n    response: {\n      attestationObject: encodeBase64Url(credential.response.attestationObject),\n      clientDataJSON: encodeBase64Url(credential.response.clientDataJSON),\n    },\n  });\n}\n\n// Conversion of data structures for Get/Assertion/Login ceremony\n\ntype AssertionPublicKeyCredential = PublicKeyCredential & {\n  response: AuthenticatorAssertionResponse;\n};\n\nfunction decodeGetOptions(value: string): CredentialRequestOptions {\n  const options = JSON.parse(value);\n  options.publicKey.challenge = decodeBase64Url(options.publicKey.challenge);\n  options.publicKey.allowCredentials?.forEach((item: any) => {\n    item.id = decodeBase64Url(item.id);\n  });\n  return options;\n}\n\nfunction encodeGetResponse(credential: AssertionPublicKeyCredential): string {\n  return JSON.stringify({\n    id: credential.id,\n    rawId: encodeBase64Url(credential.rawId),\n    type: credential.type,\n    response: {\n      authenticatorData: encodeBase64Url(credential.response.authenticatorData),\n      clientDataJSON: encodeBase64Url(credential.response.clientDataJSON),\n      signature: encodeBase64Url(credential.response.signature),\n      userHandle: credential.response.userHandle\n        ? encodeBase64Url(credential.response.userHandle)\n        : undefined,\n    },\n  });\n}\n\n// Conversion between ArrayBuffers and Base64Url strings\n\nfunction decodeBase64Url(value: string): ArrayBufferLike {\n  const base64 = value.replace(/_/g, '/').replace(/-/g, '+');\n  return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)).buffer;\n}\n\nfunction encodeBase64Url(value: ArrayBufferLike): string {\n  const base64 = btoa(String.fromCharCode.apply(null, new Uint8Array(value)));\n  return base64.replace(/\\//g, '_').replace(/\\+/g, '-').replace(/=/g, '');\n}\n\n// Exports\nexport default withCoreFns(createWebAuthn);\n","export const apiPaths = {\n  fedcm: {\n    config: '/fedcm/config',\n  },\n};\n","import { JWTResponse, SdkResponse, LoginOptions } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport { IS_BROWSER } from '../constants';\nimport { apiPaths } from '../apiPaths';\n\n/**\n * Configuration for OneTap.\n */\ninterface OneTapConfig {\n  /** Whether to auto select. Optional. */\n  auto_select?: boolean;\n\n  /** Whether to cancel on tap outside. Optional. */\n  cancel_on_tap_outside?: boolean;\n\n  /** ID of the prompt parent. Optional. */\n  prompt_parent_id?: string;\n\n  /** Context. Optional. */\n  context?: 'signin' | 'signup' | 'use';\n\n  /** Callback function to handle the intermediate iframe close event. Optional. */\n  intermediate_iframe_close_callback?: () => void;\n\n  /** Whether to support ITP. Optional. */\n  itp_support?: boolean;\n\n  /** Login hint. Optional. */\n  login_hint?: string;\n\n  /** HD. Optional. */\n  hd?: string;\n\n  /** Whether to use FedCM for prompt. Optional. */\n  use_fedcm_for_prompt?: boolean;\n}\n\n/**\n * Response from the credential.\n */\ninterface CredentialResponse {\n  /** Credential. */\n  credential: string;\n\n  /** How the selection was made. */\n  select_by:\n    | 'auto'\n    | 'user'\n    | 'user_1tap'\n    | 'user_2tap'\n    | 'btn'\n    | 'btn_confirm'\n    | 'btn_add_session'\n    | 'btn_confirm_add_session';\n}\n\ninterface FedCMAssertionResponse {\n  token: string;\n  error: {\n    code: string;\n    url: string;\n  };\n}\n\ninterface IdentityProviderConfig {\n  configURL: string;\n  clientId: string;\n}\n\ntype IdentityCredentialRequestOptionsContext =\n  | 'signin'\n  | 'signup'\n  | 'use'\n  | 'continue';\n\ninterface IdentityProviderRequestOptions extends IdentityProviderConfig {\n  nonce?: string;\n  loginHint?: string;\n  domainHint?: string;\n}\n\ninterface IdentityCredentialRequestOptions {\n  providers: IdentityProviderRequestOptions[];\n  context?: IdentityCredentialRequestOptionsContext;\n}\n\ninterface FedCMCredentialRequestOptions {\n  identity?: IdentityCredentialRequestOptions;\n}\n\ntype OneTapInitialize = ({\n  client_id,\n  callback,\n  nonce,\n}: {\n  client_id: string;\n  callback: (res: CredentialResponse) => void;\n  nonce: string;\n} & OneTapConfig) => void;\n\ntype PromptNotification = {\n  isSkippedMoment: () => boolean;\n};\n\n/**\n * Constructs a higher level FedCM API that wraps the functions from code-js-sdk.\n * @param sdk The CoreSdk instance.\n * @returns The FedCM API.\n */\nconst createFedCM = (sdk: CoreSdk, projectId: string) => ({\n  async oneTap(\n    provider?: string,\n    oneTapConfig?: OneTapConfig,\n    loginOptions?: LoginOptions,\n    onSkip?: () => void,\n  ) {\n    const readyProvider = provider ?? 'google';\n    const startResponse = await sdk.oauth.startNative(\n      readyProvider,\n      loginOptions,\n      true,\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n\n    const { clientId, stateId, nonce } = startResponse.data;\n    const googleClient = await getGoogleClient();\n    return new Promise((resolve) => {\n      const callback = (res: CredentialResponse) => {\n        resolve(\n          sdk.oauth.finishNative(\n            readyProvider,\n            stateId,\n            '',\n            '',\n            res.credential,\n          ),\n        );\n      };\n\n      // initialize google client\n      googleClient.initialize({\n        ...oneTapConfig,\n        itp_support: oneTapConfig?.itp_support ?? true,\n        use_fedcm_for_prompt: oneTapConfig?.use_fedcm_for_prompt ?? true,\n        client_id: clientId,\n        callback,\n        nonce,\n      });\n\n      googleClient.prompt((notification) => {\n        if (notification?.isSkippedMoment()) {\n          onSkip?.();\n        }\n      });\n    });\n  },\n  async launch(\n    context?: IdentityCredentialRequestOptionsContext,\n  ): Promise<SdkResponse<JWTResponse>> {\n    const configURL = sdk.httpClient.buildUrl(\n      projectId + apiPaths.fedcm.config,\n    );\n    const req: FedCMCredentialRequestOptions = {\n      identity: {\n        context: context || 'signin',\n        providers: [\n          {\n            configURL,\n            clientId: projectId,\n          },\n        ],\n      },\n    };\n    const res = await navigator.credentials?.get(req as any);\n    return sdk.refresh((res as any as FedCMAssertionResponse).token);\n  },\n  isSupported(): boolean {\n    return IS_BROWSER && 'IdentityCredential' in window;\n  },\n});\n\n// Helpers functions\nasync function getGoogleClient(): Promise<{\n  initialize: OneTapInitialize;\n  prompt: (cb: (notification: PromptNotification) => void) => void;\n}> {\n  return new Promise((resolve, reject) => {\n    if ((window as any).google) {\n      resolve((window as any).google.accounts.id);\n      return;\n    }\n\n    /* istanbul ignore next */\n    let googleScript = document.getElementById(\n      'google-gsi-client-script',\n    ) as HTMLScriptElement;\n\n    /* istanbul ignore next */\n    if (!googleScript) {\n      googleScript = document.createElement('script');\n      document.head.appendChild(googleScript);\n      googleScript.async = true;\n      googleScript.defer = true;\n      googleScript.id = 'google-gsi-client-script';\n      googleScript.src = 'https://accounts.google.com/gsi/client';\n    }\n\n    /* istanbul ignore next */\n    googleScript.onload = function () {\n      if ((window as any).google) {\n        resolve((window as any).google.accounts.id);\n      } else {\n        reject('Failed to load Google GSI client script - not loaded properly');\n      }\n    };\n    /* istanbul ignore next */\n    googleScript.onerror = function () {\n      reject('Failed to load Google GSI client script - failed to load');\n    };\n  });\n}\n\nexport default createFedCM;\nexport type { OneTapConfig };\n","import { CoreSdk, ReplaceParam } from '../types';\nimport { isSupported } from './webauthn';\n\ntype CoreSdkFlowStartArgs = Parameters<CoreSdk['flow']['start']>;\ntype Options = Pick<\n  CoreSdkFlowStartArgs[1],\n  | 'tenant'\n  | 'redirectUrl'\n  | 'redirectAuth'\n  | 'oidcIdpStateId'\n  | 'samlIdpStateId'\n  | 'samlIdpUsername'\n  | 'ssoAppId'\n  | 'oidcLoginHint'\n  | 'preview'\n  | 'abTestingKey'\n  | 'client'\n  | 'locale'\n  | 'oidcPrompt'\n  | 'oidcErrorRedirectUri'\n> & {\n  lastAuth?: Omit<CoreSdkFlowStartArgs[1]['lastAuth'], 'loginId' | 'name'>;\n};\n\nconst START_OPTIONS_VERSION_PREFER_START_REDIRECT_URL = 1;\n\nexport default (coreSdk: CoreSdk) => ({\n  ...coreSdk.flow,\n  // wrap start fn and adds more data to the start options\n  start: async (...args: ReplaceParam<CoreSdkFlowStartArgs, '1', Options>) => {\n    const webAuthnSupport = await isSupported();\n    const decoratedOptions = {\n      location: window.location.href,\n      ...args[1],\n      deviceInfo: {\n        webAuthnSupport,\n      },\n      startOptionsVersion: START_OPTIONS_VERSION_PREFER_START_REDIRECT_URL,\n    };\n\n    args[1] = decoratedOptions;\n\n    return coreSdk.flow.start(...args);\n  },\n});\n","import createCoreSdk from '@descope/core-js-sdk';\nimport createWebAuthn from './webauthn';\nimport createFedCM from './fedcm';\nimport withFlow from './flow';\nimport { getSessionToken } from '../enhancers/withPersistTokens/helpers';\n\nconst createSdk = (...args: Parameters<typeof createCoreSdk>) => {\n  const coreSdk = createCoreSdk(...args);\n\n  return {\n    ...coreSdk,\n    refresh: (token?: string) => {\n      // Descope use this query param to monitor if refresh is made\n      // When the user is already logged in in the past or not (We want to optimize that in the future)\n      const currentSessionToken = getSessionToken();\n      return coreSdk.refresh(token, { dcs: currentSessionToken ? 't' : 'f' });\n    },\n    flow: withFlow(coreSdk),\n    webauthn: createWebAuthn(coreSdk),\n    fedcm: createFedCM(coreSdk, args[0].projectId),\n  };\n};\n\nexport default createSdk;\n\nexport type CreateWebSdk = typeof createSdk;\nexport type WebSdk = ReturnType<CreateWebSdk>;\n","import { compose } from './enhancers/helpers';\nimport { withAnalytics } from './enhancers/withAnalytics';\nimport { withAutoRefresh } from './enhancers/withAutoRefresh';\nimport { withFingerprint } from './enhancers/withFingerprint';\nimport { withLastLoggedInUser } from './enhancers/withLastLoggedInUser';\nimport { withNotifications } from './enhancers/withNotifications';\nimport withPersistTokens from './enhancers/withPersistTokens';\nimport createSdk from './sdk';\n\nconst decoratedCreateSdk = compose(\n  withFingerprint,\n  withAutoRefresh,\n  withAnalytics,\n  withNotifications,\n  withLastLoggedInUser, // must be one before last due to TS types\n  withPersistTokens, // must be last due to TS known limitation https://github.com/microsoft/TypeScript/issues/30727\n)(createSdk);\n\nexport type { UserResponse } from './types';\n\n// Note: make sure to update ./test/umd.test.ts when adding new constants\nexport {\n  REFRESH_TOKEN_KEY,\n  SESSION_TOKEN_KEY,\n} from './enhancers/withPersistTokens/constants';\n\nexport {\n  ensureFingerprintIds,\n  clearFingerprintData,\n} from './enhancers/withFingerprint/helpers';\n\nexport type { OneTapConfig } from './sdk/fedcm';\n\nexport default decoratedCreateSdk;\n","type Fn = (arg: any) => any;\n\nexport function compose<Input, A1>(\n  fn1: (input: Input) => A1,\n): (input: Input) => A1;\n\nexport function compose<Input, A1, A2>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n): (input: Input) => A2;\n\nexport function compose<Input, A1, A2, A3>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n): (input: Input) => A3;\n\nexport function compose<Input, A1, A2, A3, A4>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n): (input: Input) => A4;\n\nexport function compose<Input, A1, A2, A3, A4, A5>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n): (input: Input) => A5;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n): (input: Input) => A6;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n): (input: Input) => A7;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8,\n): (input: Input) => A8;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8, A9>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8,\n  fn9: (input: A8) => A9,\n): (input: Input) => A9;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8,\n  fn9: (input: A8) => A9,\n  fn10: (input: A9) => A10,\n): (input: Input) => A10;\n\n/**\n * Currently there is no way to create a compose function in Typescript without using overloading\n * This function currently support up to 10 wrappers\n * If needed you can add more by duplicating the type and add more parameters\n */\n\nexport function compose(...args: Fn[]) {\n  return (data: any) => args.reduce((acc, elem) => elem(acc), data) as any;\n}\n","import { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport { addHooks, getAuthInfoFromResponse } from '../helpers';\nimport {\n  createTimerFunctions,\n  getTokenExpiration,\n  millisecondsUntilDate,\n} from './helpers';\nimport { AutoRefreshOptions } from './types';\nimport logger from '../helpers/logger';\nimport { IS_BROWSER, MAX_TIMEOUT } from '../../constants';\nimport { getRefreshToken } from '../withPersistTokens/helpers';\n\n// The amount of time (ms) to trigger the refresh before session expires\nconst REFRESH_THRESHOLD = 20 * 1000; // 20 sec\n\n/**\n * Automatically refresh the session token before it expires\n * It uses the the refresh token that is extracted from API response to do that\n */\nexport const withAutoRefresh =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  ({ autoRefresh, ...config }: Parameters<T>[0] & AutoRefreshOptions) => {\n    if (!autoRefresh) return createSdk(config);\n\n    // if we hold a single timer id, there might be a case where we override it before canceling the timer, this might cause many calls to refresh\n    // in order to prevent it, we hold a list of timers and cancel all of them when a new timer is set, which means we should have one active timer only at a time\n    const { clearAllTimers, setTimer } = createTimerFunctions();\n\n    // we need to hold the expiration time and the refresh token in order to refresh the session\n    // when the user comes back to the tab or from background/lock screen/etc.\n    let sessionExpiration: Date;\n    let refreshToken: string;\n    if (IS_BROWSER) {\n      document.addEventListener('visibilitychange', () => {\n        // tab becomes visible and the session is expired, do a refresh\n        if (\n          document.visibilityState === 'visible' &&\n          new Date() > sessionExpiration\n        ) {\n          logger.debug('Expiration time passed, refreshing session');\n          // We prefer the persisted refresh token over the one from the response\n          // for a case that the token was refreshed from another tab, this mostly relevant\n          // when the project uses token rotation\n          sdk.refresh(getRefreshToken() || refreshToken);\n        }\n      });\n    }\n\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      const { refreshJwt, sessionJwt } = await getAuthInfoFromResponse(res);\n\n      // if we got 401 we want to cancel all timers\n      if (res?.status === 401) {\n        logger.debug('Received 401, canceling all timers');\n        clearAllTimers();\n      } else if (sessionJwt) {\n        sessionExpiration = getTokenExpiration(sessionJwt);\n        if (!sessionExpiration) {\n          logger.debug('Could not extract expiration time from session token');\n          return;\n        }\n        refreshToken = refreshJwt;\n        let timeout =\n          millisecondsUntilDate(sessionExpiration) - REFRESH_THRESHOLD;\n\n        if (timeout > MAX_TIMEOUT) {\n          logger.debug(\n            `Timeout is too large (${timeout}ms), setting it to ${MAX_TIMEOUT}ms`,\n          );\n          timeout = MAX_TIMEOUT;\n        }\n        clearAllTimers();\n\n        const refreshTimeStr = new Date(\n          Date.now() + timeout,\n        ).toLocaleTimeString('en-US', { hour12: false });\n        logger.debug(\n          `Setting refresh timer for ${refreshTimeStr}. (${timeout}ms)`,\n        );\n\n        setTimer(() => {\n          logger.debug('Refreshing session due to timer');\n          // We prefer the persisted refresh token over the one from the response\n          // for a case that the token was refreshed from another tab, this mostly relevant\n          // when the project uses token rotation\n          sdk.refresh(getRefreshToken() || refreshJwt);\n        }, timeout);\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    const wrapper: SdkFnWrapper<{}> =\n      (fn) =>\n      async (...args) => {\n        const resp = await fn(...args);\n        logger.debug('Clearing all timers');\n        clearAllTimers();\n\n        return resp;\n      };\n\n    return wrapWith(sdk, ['logout', 'logoutAll'], wrapper);\n  };\n","import { jwtDecode, JwtPayload } from 'jwt-decode';\n\n/**\n * Get the JWT expiration WITHOUT VALIDATING the JWT\n * @param token The JWT to extract expiration from\n * @returns The Date for when the JWT expires or null if there is an issue\n */\nexport const getTokenExpiration = (token: string) => {\n  try {\n    const claims = jwtDecode<JwtPayload>(token);\n    if (claims.exp) {\n      return new Date(claims.exp * 1000);\n    }\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const millisecondsUntilDate = (date: Date) =>\n  date ? date.getTime() - new Date().getTime() : 0;\n\nexport const createTimerFunctions = () => {\n  const timerIds: NodeJS.Timeout[] = [];\n\n  const clearAllTimers = () => {\n    while (timerIds.length) {\n      clearTimeout(timerIds.pop());\n    }\n  };\n\n  const setTimer = (cb: () => void, timeout: number) => {\n    timerIds.push(setTimeout(cb, timeout));\n  };\n\n  return { clearAllTimers, setTimer };\n};\n","import { CreateWebSdk } from '../sdk';\nimport { BeforeRequestHook } from '../types';\nimport { addHooks } from './helpers';\n\n// this is replaced in build time\ndeclare const BUILD_VERSION: string;\n/**\n * Adds analytics headers to requests\n */\nexport const withAnalytics =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  (config: Parameters<T>[0]) =>\n    createSdk({\n      ...config,\n      baseHeaders: {\n        'x-descope-sdk-name': 'web-js',\n        'x-descope-sdk-version': BUILD_VERSION,\n        ...config.baseHeaders,\n      },\n    });\n"],"names":["addHooks","config","hooks","reduce","acc","key","concat","_a","getAuthInfoFromResponse","async","res","ok","body","clone","json","authInfo","getUserFromResponse","user","hasOwnProperty","undefined","isLocalStorage","localStorage","setLocalStorage","value","setItem","getLocalStorage","getItem","removeLocalStorage","removeItem","logger","args","console","debug","IS_BROWSER","window","MAX_TIMEOUT","Math","pow","SESSION_TOKEN_KEY","REFRESH_TOKEN_KEY","setJwtTokenCookie","name","cookiePath","cookieDomain","cookieExpiration","expires","Date","domainMatches","currentDomainParts","location","hostname","split","cookieDomainParts","slice","length","join","isCurrentDomainOrParentDomain","Cookies","set","path","domain","sameSite","secure","getRefreshToken","prefix","getSessionToken","default","get","clearTokens","remove","FP_EP_URL","FP_STORAGE_KEY","getFPFromStorage","returnExpired","itemStr","item","JSON","parse","getTime","expiry","ensureFingerprintIds","fpKey","baseUrl","sessionId","now","toString","random","substring","endpointUrl","URL","pathname","patterUrl","scriptUrlPattern","agentP","load","apiKey","endpoint","defaultEndpoint","defaultScriptUrlPattern","agent","requestId","linkedId","fpData","vsid","vrid","createFingerprintObject","stringify","setFPToStorage","ex","warn","beforeRequest","data","LOCAL_STORAGE_LAST_USER_LOGIN_ID","LOCAL_STORAGE_LAST_USER_DISPLAY_NAME","getLastUserLoginId","getLastUserDisplayName","startWrapper","fn","options","loginId","displayName","lastAuth","logoutWrapper","keepOnLogout","resp","createPubSub","cbs","pub","forEach","cb","sub","idx","push","splice","wrapper","create","createOptions","publicKey","challenge","decodeBase64Url","id","excludeCredentials","decodeCreateOptions","createResponse","navigator","credentials","credential","rawId","encodeBase64Url","type","response","attestationObject","clientDataJSON","getOptions","decodeGetOptions","encodeGetResponse","conditional","abort","signal","mediation","isSupported","requirePlatformAuthenticator","Promise","resolve","supported","PublicKeyCredential","isUserVerifyingPlatformAuthenticatorAvailable","allowCredentials","authenticatorData","signature","userHandle","base64","replace","Uint8Array","from","atob","c","charCodeAt","buffer","btoa","String","fromCharCode","apply","creator","createWebAuthn$1","sdk","identifier","startResponse","webauthn","signUp","start","origin","finish","transactionId","signIn","getResponse","signUpOrIn","token","update","helpers","obj","Object","assign","apiPaths","createFedCM","projectId","provider","oneTapConfig","loginOptions","onSkip","readyProvider","oauth","startNative","clientId","stateId","nonce","googleClient","reject","google","accounts","googleScript","document","getElementById","createElement","head","appendChild","defer","src","onload","onerror","getGoogleClient","initialize","itp_support","use_fedcm_for_prompt","_b","client_id","callback","finishNative","prompt","notification","isSkippedMoment","context","req","identity","providers","configURL","httpClient","buildUrl","refresh","withFlow","coreSdk","flow","webAuthnSupport","decoratedOptions","href","deviceInfo","startOptionsVersion","decoratedCreateSdk","elem","compose","createSdk","fpLoad","__rest","catch","autoRefresh","clearAllTimers","setTimer","timerIds","clearTimeout","pop","timeout","setTimeout","createTimerFunctions","sessionExpiration","refreshToken","addEventListener","visibilityState","afterRequest","_req","refreshJwt","sessionJwt","status","claims","jwtDecode","exp","e","getTokenExpiration","date","refreshTimeStr","toLocaleTimeString","hour12","wrapWith","baseHeaders","sessionPS","userPS","userDetails","wrappedSdk","onSessionTokenChange","onUserChange","storeLastAuthenticatedUser","keepLastAuthenticatedUserAfterLogout","loginIds","setLastUserLoginId","setLastUserDisplayName","persistTokens","isPersistTokens","sessionTokenViaCookie","storagePrefix","isManagementApi","test","cookieParams","createCoreSdk","currentSessionToken","dcs","createWebAuthn","fedcm"],"mappings":"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"}